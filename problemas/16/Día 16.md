##Día 16
### Justificación
Se eligió este problema porque nos pareció  interesante y en los exámenes de años anteriores hay ejercicios similares de encontrar caminos en  tableros. Lo vimos también como una oportunidad para implementar programación dinámica marcando las posiciones visitadas.

### Descripción técnica

#### Primera Parte
 Dado un laberinto con casillas S y E que marcan el comienzo y el final respectivamente, se pide encontrar el coste del camino más corto. Hay movimientos hacia adelante, lo que tiene un coste de 1, o rotar 90 grados, lo que tiene un coste de 1000.

 Primero vamos a declarar una clase Punto con los atributos de posición, dirección y coste asociado. Además tendrá los métodos que cambiarán las coordenadas necesarias para avanzar o rotar, y un método para comprobar si la posición es válida, es decir si no es un muro (#). No es necesario comprobar si se sale de las posiciones válidas ya que el laberinto está rodeado por muros. También hay un operador `>` que devuelve si el coste del punto es mayor que el coste de otro punto que se la pasa. Este nos servirá para el algoritmo de búsqueda que se explica a continuación. 

Para obtener el problema se ha hecho una búsqueda en anchura, pero modificando la cola. Una búsqueda en anchura garantiza encontrar el camino más corto para grafos no ponderados, ya que primero se visitan todos los vecinos antes de pasar al siguiente nivel, es decir los que solo están a un “paso” de distancia. Por lo tanto, el BFS garantiza que la primera vez que se encuentra el destino es con el camino más corto. Ahora bien, esto es un grafo ponderado con costes que varían dependiendo de la dirección. Entonces, ¿cómo garantizamos que se recorren primero los vecinos con menor costo asociado? Con una cola de prioridad donde se priorizan los movimientos con menor coste acumulado. Así se garantiza también que la primera vez que se encuentra el destino es con el menor coste. El algoritmo funciona de la siguiente manera:
 Primero se necesita una memoria ```vector<vector<int>> visitados(rows, vector<int>(cols, 0)``` que almacena el costo mínimo para llegar a cada posición y, la cual se inicializa a 0 para marcar que no se ha visitado esa posición. También tenemos que declarar nuestra cola de prioridad ```priority_queue<Punto, vector<Punto>, greater<Punto>> pq```. Metemos el punto inicial a la cola y procesamos los nodos mientras la cola no esté vacía. Sacamos de la cola el nodo actual y se hacen las siguientes comprobaciones: si es el final, devolvemos la matriz de visitados, si ya está visitado(es diferente de 0 en la memoria) volvemos al principio del bucle y si no guardamos su coste en la memoria. Ahora calculamos el coste acumulado de los siguientes movimientos posibles. Para ello creamos tres puntos nuevos y, respecto del punto actual, les aplicamos los movimientos de moverse hacia adelante, rotar izquierda y avanzar o rotar derecha y avanzar. Si son válidos, van a tener el coste del actual + 1 para el de avanzar y 1001 para los que combinan rotación y avanzar. Después de calcular sus costes se insertan en la cola, que se reordenará. Si se vaciase se habrían procesado todos los nodos y en la memoria habrían quedado almacenados los caminos más cortos para todos los nodos, como en el algoritmo de Dijkstra, pero el algoritmo está hecho para que pare y devuelve la matriz de visitados cuando encuentra el punto destino. Así una vez ejecutado el BFS bastará con acceder a la posición de ´E´ en la memoria y ahí estará el resultado. 

### ALTERNATIVAS

En un principio se implementó con llamadas recursivas. En esta versión también había memoria y se llamaban a todos los movimientos posibles, pero los puntos no tenían un coste asociado como tal, sino que se devolvía el mínimo de las tres llamadas recursivas sumándoles sus respectivos costes. Esta versión funcionaba para los laberintos pequeños de los ejemplos, pero era extremadamente ineficiente para el laberinto grande. Así que se decidió recurrir a algoritmos propios de grafos como  A* o  Dijkstra. Finalmente nos decidimos por la versión modificada del BFS, ya que era la más parecida a las técnicas vistas en clase, aunque como hemos mencionado es muy similar a Dijkstra.

### VALORACIÓN PERSONAL 
Consideramos que este problema ha sido un reto y ha presentado una dificultad mayor que la que esperábamos en un principio, pues el tener que rechazar la recursividad y buscar otras soluciones usando algoritmos de búsqueda fue la parte que más nos costó. Aunque al final se haya solucionado con un BFS con cola de prioridad, creemos que también nos ha servido para darnos una noción sobre más algoritmos de búsqueda como los mencionados Dijkstra o A*. Nos ha parecido un problema bastante completo y un reto entretenido, aunque por momentos frustrante. 
