## Día 5
### Justificación
 Elegimos este problema porque fue el primer día en el que detectamos que claramente nos encontrábamos ante un grafo de precedencia, y como todavía no habían salido más y teníamos tiempo antes de empezar exámenes, decidimos hacerlo. Si bien la dificultad no era demasiado alta, lo vimos como un problema para tener un primer contacto con grafos. 
### Descripción técnica
#### Primera Part
 Para la primera parte se nos dan varias reglas del tipo A|B, donde A debe preceder a B. Después, aparecen secuencias de números y se debe comprobar si todos los números de la secuencia cumplen las reglas que tienen asociadas. Sabiendo las secuencias correctas, debemos calcular la suma de los números del medio de todas las secuencias correctas.

Lo primero de todos es crear el grafo. Para ello se usa un diccionario ```unordered_map<int, unordered_set<int>> grafo```. Las claves son números enteros y el valor que tienen asociado es un conjunto de enteros, el cual contiene todos los números que deben ir después del número de la clave. Para ir rellenando el grafo,  se lee línea por línea un fichero con el input. Si se lee el carácter ‘|’,  se trata de una norma (al principio se quiso usar una función ```vector<int> split()``` que implementamos, pero misteriosamente hacía que el algoritmo de la segunda parte no funcionase correctamente).  Así que tomamos carácter por carácter e hicimos las operaciones necesarias para convertirlos a enteros. Al primer número lo llamamos A y al segundo B, y luego hacemos ```grafo[A].pushback(B)``` y así al acceder acceder a ```grafo[A]``` tendremos todos los números que deben ir después de A. 

Cuando ya no leemos ‘|’, se trata de una secuencia, y aquí sí que usamos la función split, la cual devuelve un vector con los números leídos. Para comprobar si es correcta vamos a usar dos funciones. La primera es ```bool a_b(int a, int b, const unordered_map<int, unordered_set<int>>& grafo)``` , la cual devuelve si b debe ir después de a según las reglas. Para ello es tan simple como devolver si ```b``` se encuentra en ```grafo[a]```. Después, definimos una función llamada ```bool cumple_reglas(vector<int> input, const unordered_map<int, unordered_set<int>>& grafo)```. Esta usa dos bucles ```for```  anidados, el primero, recorriendo el vector input del último al primero, toma un número ```i``` y el anidado recorre el resto de números ```j```. Así por cada iteración se se llama a ```a_b(i, j, grafo)```. Si a_b() devuelve ```true``` significa que se ha encontrado un número j antes de i, pero que según las reglas debería ir después de i, así que la línea input es incorrecta. Por cada línea llamamos a cumple_reglas() y si las cumple calculamos el número del medio y lo sumamos a la variable de la suma de los correctos. 

 
#### Segunda Parte

Para la segunda parte se pide ordenar las secuencias que no cumplen las reglas, y como en la primera parte, calcular la suma de los elementos del medio. Como se pide que se ordenen, asumimos que los números de cada secuencia no forman un grafo cíclico. 

Si la función cumple_reglas() devuelve ```false```, se llama a una función ```vector<int> sortUpdate(const vector<int> &update, const unordered_map<int, unordered_set<int>>& grafo)``` que aplica un orden topológico. Primero, sea crea un ```unordered_map<int, vector<int>> grafo_temp```, que sirve como un grafo temporal que únicamente contiene los nodos que aparecen en la línea update, y un ```unordered_map<int, int> inDegree``` que es un diccionario que contiene los grados de entrada de los nodos del grafo temporal, el cual inicialmente tiene todos los valores 0. Luego se lee el grafo original y se rellenan el grafo temporal y el diccionario de los grados de entrada. Una vez tenemos las estructuras de datos necesarias, se aplica el orden topológico usando el algoritmo de Kahn, el cual usa una cola ``` queue<int> q```. Inicialmente, entran a la cola todos los nodos con grado de entrada 0, pues no dependen de nadie y pueden ir primero. Después, mientras la cola no esté vacía se procesan los nodos: para comenzar, sale el primer nodo de la fila y lo añadimos a nuestro vector ```vector<int> ordenado```, después, decrementamos el grado de entrada de los nodos a los que apuntaba el nodo que ha salido y si estos también han quedado sin grados de entrada, los añadimos a la cola. Cuando la cola esté vacía, significa que hemos procesado todos los nodos, así que devolvemos el vector ordenado. Actualizamos la secuencia de números, ahora correctamente ordenada, y procedemos igual que en la primera parte para calcular la suma.

### Alternativas 
En un principio se pensó en usar un array estático con 90 posiciones, ya que los números van del 10 al 99, pero nos dimos cuenta de que se desperdiciaba demasiada memoria y optamos por el unordered_map. Por otro lado, en otro momento también se almacenaron las precedencias de forma inversa a la actual, es decir, en grafo[B] se almacenaban todos los números A que debían ir antes de B. Así la función a_b() devolvía si a debía ir antes de b. Además para la parte de ordenación, y con la excusa de usar Divide y Vencerás, probamos con un MergeSort() modificado, donde sustituimos el operador “<” por la función a_b() a la hora de ordenar los números. Este MergeSort() funcionaba pero era muy ineficiente hacer tantas comprobaciones, así que finalmente implementamos el algoritmo de Kahn. De todos modos quedan algunos misterios sin   resolver. Por ejemplo, al principio en lugar de split se usaba un ```while ((pos=linea.find(',')) != string::npos)``` y se iban metiendo los números haciendo un ```stoi()``` por cada número. Esta maner de leer, por alguna razón hacía que el orden topológico no funcionase correctamente, cosa que con el split() no pasa. Además hay una función para imprimir el grafo y por un motivo que escapa nuestro entendimiento se guarda una clave: -479 con valor 37, aunque no afecta al resultado.

### Valoración Personal 

Creemos que este problema nos ha servido para establecer las bases de cómo implementar grafos dirigidos en C++ y ordenarlos. En la parte personal, si bien el problema no parecía demasiado complicado y teníamos claro lo que debíamos hacer, han aparecido problemas y complicaciones, como los misterios mencionados en las alternaticas. Es algo que ha resultado muy frustrante pero entendemos que es parte del aprendizaje y ayuda a enfrentar futuros problemas.  

